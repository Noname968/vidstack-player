import {
  DOMEvent,
  IS_CHROME,
  IS_IOS,
  IS_SERVER,
  canGoogleCastSrc,
  coerceToError,
  listen,
  loadScript,
  peek
} from "./chunk-NQW6PDO3.js";

// node_modules/@vidstack/react/dist/dev/chunks/vidstack-2k_oWHKR.js
function getCastFrameworkURL() {
  return "https://www.gstatic.com/cv/js/sender/v1/cast_sender.js?loadCastFramework=1";
}
function hasLoadedCastFramework() {
  var _a;
  return !!((_a = window.cast) == null ? void 0 : _a.framework);
}
function isCastAvailable() {
  var _a, _b;
  return !!((_b = (_a = window.chrome) == null ? void 0 : _a.cast) == null ? void 0 : _b.isAvailable);
}
function isCastConnected() {
  return getCastContext().getCastState() === cast.framework.CastState.CONNECTED;
}
function getCastContext() {
  return window.cast.framework.CastContext.getInstance();
}
function getCastSession() {
  return getCastContext().getCurrentSession();
}
function getCastSessionMedia() {
  var _a;
  return (_a = getCastSession()) == null ? void 0 : _a.getSessionObj().media[0];
}
function hasActiveCastSession(src) {
  var _a;
  const contentId = (_a = getCastSessionMedia()) == null ? void 0 : _a.media.contentId;
  return contentId === (src == null ? void 0 : src.src);
}
function getDefaultCastOptions() {
  return {
    language: "en-US",
    autoJoinPolicy: chrome.cast.AutoJoinPolicy.ORIGIN_SCOPED,
    receiverApplicationId: chrome.cast.media.DEFAULT_MEDIA_RECEIVER_APP_ID,
    resumeSavedSession: true,
    androidReceiverCompatible: true
  };
}
function getCastErrorMessage(code) {
  const defaultMessage = `Google Cast Error Code: ${code}`;
  {
    switch (code) {
      case chrome.cast.ErrorCode.API_NOT_INITIALIZED:
        return "The API is not initialized.";
      case chrome.cast.ErrorCode.CANCEL:
        return "The operation was canceled by the user";
      case chrome.cast.ErrorCode.CHANNEL_ERROR:
        return "A channel to the receiver is not available.";
      case chrome.cast.ErrorCode.EXTENSION_MISSING:
        return "The Cast extension is not available.";
      case chrome.cast.ErrorCode.INVALID_PARAMETER:
        return "The parameters to the operation were not valid.";
      case chrome.cast.ErrorCode.RECEIVER_UNAVAILABLE:
        return "No receiver was compatible with the session request.";
      case chrome.cast.ErrorCode.SESSION_ERROR:
        return "A session could not be created, or a session was invalid.";
      case chrome.cast.ErrorCode.TIMEOUT:
        return "The operation timed out.";
      default:
        return defaultMessage;
    }
  }
}
function listenCastContextEvent(type, handler) {
  return listen(getCastContext(), type, handler);
}
var GoogleCastLoader = class {
  constructor() {
    this.name = "google-cast";
  }
  /**
   * @see {@link https://developers.google.com/cast/docs/reference/web_sender/cast.framework.CastContext}
   */
  get cast() {
    return getCastContext();
  }
  mediaType() {
    return "video";
  }
  canPlay(src) {
    return IS_CHROME && !IS_IOS && canGoogleCastSrc(src);
  }
  async prompt(ctx) {
    var _a;
    let openEvent;
    try {
      const loadEvent = await this._loadCastFramework(ctx);
      if (!this._player) {
        this._player = new cast.framework.RemotePlayer();
        new cast.framework.RemotePlayerController(this._player);
      }
      openEvent = ctx.player.createEvent("google-cast-prompt-open", {
        trigger: loadEvent
      });
      ctx.player.dispatchEvent(openEvent);
      this._notifyRemoteStateChange(ctx, "connecting", openEvent);
      await this._showPrompt(peek(ctx.$props.googleCast));
      ctx.$state.remotePlaybackInfo.set({
        deviceName: (_a = getCastSession()) == null ? void 0 : _a.getCastDevice().friendlyName
      });
      if (isCastConnected())
        this._notifyRemoteStateChange(ctx, "connected", openEvent);
    } catch (message) {
      const error = coerceToError(message);
      this._notifyRemoteStateChange(
        ctx,
        isCastConnected() ? "connected" : "disconnected",
        new DOMEvent("google-cast-prompt-error", { detail: error })
      );
      throw error;
    } finally {
      ctx.player.dispatch("google-cast-prompt-close", {
        trigger: openEvent
      });
    }
  }
  async load(ctx) {
    if (IS_SERVER) {
      throw Error("[vidstack] can not load google cast provider server-side");
    }
    if (!this._player) {
      throw Error("[vidstack] google cast player was not initialized");
    }
    return new (await import("./vidstack-BT4_nnPA-POLC36YH.js")).GoogleCastProvider(this._player, ctx);
  }
  async _loadCastFramework(ctx) {
    if (hasLoadedCastFramework())
      return;
    const loadStartEvent = ctx.player.createEvent("google-cast-load-start");
    ctx.player.dispatch(loadStartEvent);
    await loadScript(getCastFrameworkURL());
    await customElements.whenDefined("google-cast-launcher");
    const loadedEvent = ctx.player.createEvent("google-cast-loaded", { trigger: loadStartEvent });
    ctx.player.dispatch(loadedEvent);
    if (!isCastAvailable()) {
      throw Error(
        "Google Cast is not available on this platform."
      );
    }
    return loadedEvent;
  }
  async _showPrompt(options) {
    this._setOptions(options);
    const errorCode = await this.cast.requestSession();
    if (errorCode)
      throw Error(getCastErrorMessage(errorCode));
  }
  _setOptions(options) {
    var _a;
    (_a = this.cast) == null ? void 0 : _a.setOptions({
      ...getDefaultCastOptions(),
      ...options
    });
  }
  _notifyRemoteStateChange(ctx, state, trigger) {
    const detail = { type: "google-cast", state };
    ctx.delegate._notify("remote-playback-change", detail, trigger);
  }
};
var loader = Object.freeze({
  __proto__: null,
  GoogleCastLoader
});

export {
  getCastContext,
  getCastSession,
  getCastSessionMedia,
  hasActiveCastSession,
  getCastErrorMessage,
  listenCastContextEvent,
  loader
};
//# sourceMappingURL=chunk-TJSBMHSG.js.map
